<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Restgoose: pml::restgoose::Server Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Restgoose
   </div>
   <div id="projectbrief">RESTful Server and Client + Websockets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classpml_1_1restgoose_1_1Server.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpml_1_1restgoose_1_1Server-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pml::restgoose::Server Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17412c44f2147d64c22340dccf2b6aa3" id="r_a17412c44f2147d64c22340dccf2b6aa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a17412c44f2147d64c22340dccf2b6aa3">Init</a> (const std::filesystem::path &amp;ca, const std::filesystem::path &amp;cert, const std::filesystem::path &amp;key, const <a class="el" href="classNamedType.html">ipAddress</a> &amp;addr, unsigned short nPort, const <a class="el" href="classNamedType.html">endpoint</a> &amp;apiRoot, bool bEnableWebsocket, bool bSendPings=false)</td></tr>
<tr class="memdesc:a17412c44f2147d64c22340dccf2b6aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the server.  <br /></td></tr>
<tr class="separator:a17412c44f2147d64c22340dccf2b6aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c8f884ad0cfbdd36a064d8fce8d7a4" id="r_a76c8f884ad0cfbdd36a064d8fce8d7a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a76c8f884ad0cfbdd36a064d8fce8d7a4">Init</a> (const std::filesystem::path &amp;cert, const std::filesystem::path &amp;key, const <a class="el" href="classNamedType.html">ipAddress</a> &amp;addr, unsigned short nPort, const <a class="el" href="classNamedType.html">endpoint</a> &amp;apiRoot, bool bEnableWebsocket, bool bSendPings=false)</td></tr>
<tr class="memdesc:a76c8f884ad0cfbdd36a064d8fce8d7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the server.  <br /></td></tr>
<tr class="separator:a76c8f884ad0cfbdd36a064d8fce8d7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172f5f57f9a90adb3cc8c001d2311774" id="r_a172f5f57f9a90adb3cc8c001d2311774"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a172f5f57f9a90adb3cc8c001d2311774">Init</a> (const <a class="el" href="classNamedType.html">ipAddress</a> &amp;addr, unsigned short nPort, const <a class="el" href="classNamedType.html">endpoint</a> &amp;apiRoot, bool bEnableWebsocket, bool bSendPings=false)</td></tr>
<tr class="memdesc:a172f5f57f9a90adb3cc8c001d2311774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the server.  <br /></td></tr>
<tr class="separator:a172f5f57f9a90adb3cc8c001d2311774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82520a2dd424c185dec9dc6771ee063" id="r_ab82520a2dd424c185dec9dc6771ee063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#ab82520a2dd424c185dec9dc6771ee063">Run</a> (bool bThread, const std::chrono::milliseconds &amp;timeout=std::chrono::milliseconds(100))</td></tr>
<tr class="memdesc:ab82520a2dd424c185dec9dc6771ee063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the webserver.  <br /></td></tr>
<tr class="separator:ab82520a2dd424c185dec9dc6771ee063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7d8cace41bf8ed40aa7ad4f4b6dfb6" id="r_aee7d8cace41bf8ed40aa7ad4f4b6dfb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#aee7d8cace41bf8ed40aa7ad4f4b6dfb6">SetInterface</a> (const <a class="el" href="classNamedType.html">ipAddress</a> &amp;addr, unsigned short nPort)</td></tr>
<tr class="memdesc:aee7d8cace41bf8ed40aa7ad4f4b6dfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interface and port to run on. If the webserver is already running this will have no effect until it is restarted.  <br /></td></tr>
<tr class="separator:aee7d8cace41bf8ed40aa7ad4f4b6dfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e46072061d99f904755975c84739e6a" id="r_a9e46072061d99f904755975c84739e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a9e46072061d99f904755975c84739e6a">SetAuthorizationTypeBearer</a> (const std::function&lt; bool(const methodpoint &amp;, const std::string &amp;theToken)&gt; &amp;callback, const std::function&lt; <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a>(const <a class="el" href="classNamedType.html">endpoint</a> &amp;, bool)&gt; &amp;callbackHandleNotAuthorized, bool bAuthenticateWebsocketsViaQuery)</td></tr>
<tr class="memdesc:a9e46072061d99f904755975c84739e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the authorization type to expect a bearer token in the Authorization header.  <br /></td></tr>
<tr class="separator:a9e46072061d99f904755975c84739e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67c7c51c7a9da46277d4fe5ea624110" id="r_aa67c7c51c7a9da46277d4fe5ea624110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#aa67c7c51c7a9da46277d4fe5ea624110">SetAuthorizationTypeBasic</a> (const <a class="el" href="classNamedType.html">userName</a> &amp;aUser, const <a class="el" href="classNamedType.html">password</a> &amp;aPassword)</td></tr>
<tr class="memdesc:aa67c7c51c7a9da46277d4fe5ea624110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the authorization type to basic authentication.  <br /></td></tr>
<tr class="separator:aa67c7c51c7a9da46277d4fe5ea624110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ced561806cea939b759800da042fda" id="r_af2ced561806cea939b759800da042fda"><td class="memItemLeft" align="right" valign="top"><a id="af2ced561806cea939b759800da042fda" name="af2ced561806cea939b759800da042fda"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetAuthorizationTypeNone</b> ()</td></tr>
<tr class="memdesc:af2ced561806cea939b759800da042fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all authorization. <br /></td></tr>
<tr class="separator:af2ced561806cea939b759800da042fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b1c291c4960827a3655f99efb21030" id="r_a40b1c291c4960827a3655f99efb21030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a40b1c291c4960827a3655f99efb21030">SetUnprotectedEndpoints</a> (const std::set&lt; methodpoint &gt; &amp;setUnprotected)</td></tr>
<tr class="memdesc:a40b1c291c4960827a3655f99efb21030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a set of methodpoints that do not need to be authenticated (e.g. to show an initial login page)  <br /></td></tr>
<tr class="separator:a40b1c291c4960827a3655f99efb21030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2131a6573102ab1949f00d2f66b700ea" id="r_a2131a6573102ab1949f00d2f66b700ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a2131a6573102ab1949f00d2f66b700ea">AddBAUser</a> (const <a class="el" href="classNamedType.html">userName</a> &amp;aUser, const <a class="el" href="classNamedType.html">password</a> &amp;aPassword)</td></tr>
<tr class="memdesc:a2131a6573102ab1949f00d2f66b700ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a basic authentication user/password pair to the server.  <br /></td></tr>
<tr class="separator:a2131a6573102ab1949f00d2f66b700ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b0d58606adac7831bfd720578b296d" id="r_af7b0d58606adac7831bfd720578b296d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#af7b0d58606adac7831bfd720578b296d">DeleteBAUser</a> (const <a class="el" href="classNamedType.html">userName</a> &amp;aUser)</td></tr>
<tr class="memdesc:af7b0d58606adac7831bfd720578b296d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a user from basic authentication.  <br /></td></tr>
<tr class="separator:af7b0d58606adac7831bfd720578b296d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d58452457a7a785ada7a61067d646" id="r_ad62d58452457a7a785ada7a61067d646"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#ad62d58452457a7a785ada7a61067d646">AddWebsocketEndpoint</a> (const <a class="el" href="classNamedType.html">endpoint</a> &amp;theEndpoint, const std::function&lt; bool(const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const query &amp;, const <a class="el" href="classNamedType.html">userName</a> &amp;, const <a class="el" href="classNamedType.html">ipAddress</a> &amp;)&gt; &amp;funcAuthentication, const std::function&lt; bool(const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const Json::Value &amp;)&gt; &amp;funcMessage, const std::function&lt; void(const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const <a class="el" href="classNamedType.html">ipAddress</a> &amp;)&gt; &amp;funcClose)</td></tr>
<tr class="memdesc:ad62d58452457a7a785ada7a61067d646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an enpoint that a websocket client can connect to along with callback functions.  <br /></td></tr>
<tr class="separator:ad62d58452457a7a785ada7a61067d646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2eb768de72271b9137fb27c4bedfe6" id="r_a5b2eb768de72271b9137fb27c4bedfe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a5b2eb768de72271b9137fb27c4bedfe6">AddNotFoundCallback</a> (const std::function&lt; <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a>(const <a class="el" href="classNamedType.html">httpMethod</a> &amp;, const query &amp;, const std::vector&lt; <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> &gt; &amp;, const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const <a class="el" href="classNamedType.html">userName</a> &amp;)&gt; &amp;func)</td></tr>
<tr class="memdesc:a5b2eb768de72271b9137fb27c4bedfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function to be called everytime a client attempts to connect to a methodpoint that is not defined.  <br /></td></tr>
<tr class="separator:a5b2eb768de72271b9137fb27c4bedfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4edfff9dcb12b77eb5240791ede432" id="r_a6e4edfff9dcb12b77eb5240791ede432"><td class="memItemLeft" align="right" valign="top"><a id="a6e4edfff9dcb12b77eb5240791ede432" name="a6e4edfff9dcb12b77eb5240791ede432"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Stop</b> ()</td></tr>
<tr class="separator:a6e4edfff9dcb12b77eb5240791ede432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a8695e1ce0da3d8ecdd32162e48319" id="r_a05a8695e1ce0da3d8ecdd32162e48319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a05a8695e1ce0da3d8ecdd32162e48319">SetMaxConnections</a> (size_t nMax)</td></tr>
<tr class="memdesc:a05a8695e1ce0da3d8ecdd32162e48319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of connections the server will accept.  <br /></td></tr>
<tr class="separator:a05a8695e1ce0da3d8ecdd32162e48319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427545c00df56cfa22c9dfbf72f816b0" id="r_a427545c00df56cfa22c9dfbf72f816b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a427545c00df56cfa22c9dfbf72f816b0">SetAccessControlList</a> (const std::string &amp;sAcl)</td></tr>
<tr class="memdesc:a427545c00df56cfa22c9dfbf72f816b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the access control list for the server.  <br /></td></tr>
<tr class="separator:a427545c00df56cfa22c9dfbf72f816b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48d416c881e8cccd31f6b6bcd243f31" id="r_ae48d416c881e8cccd31f6b6bcd243f31"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#ae48d416c881e8cccd31f6b6bcd243f31">GetAccessControlList</a> () const</td></tr>
<tr class="memdesc:ae48d416c881e8cccd31f6b6bcd243f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the access control list.  <br /></td></tr>
<tr class="separator:ae48d416c881e8cccd31f6b6bcd243f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7678afd43a6f601283076016971cf2eb" id="r_a7678afd43a6f601283076016971cf2eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a7678afd43a6f601283076016971cf2eb">AddEndpoint</a> (const <a class="el" href="classNamedType.html">httpMethod</a> &amp;method, const <a class="el" href="classNamedType.html">endpoint</a> &amp;theEndpoint, const std::function&lt; <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a>(const query &amp;, const std::vector&lt; <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> &gt; &amp;, const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const <a class="el" href="classNamedType.html">userName</a> &amp;)&gt; &amp;func, bool bUseThread=false)</td></tr>
<tr class="separator:a7678afd43a6f601283076016971cf2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856f15350b38e6b51606a4a592cc7367" id="r_a856f15350b38e6b51606a4a592cc7367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a856f15350b38e6b51606a4a592cc7367">DeleteEndpoint</a> (const <a class="el" href="classNamedType.html">httpMethod</a> &amp;method, const <a class="el" href="classNamedType.html">endpoint</a> &amp;theEndpoint)</td></tr>
<tr class="separator:a856f15350b38e6b51606a4a592cc7367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cde40b39450043f88060a5d1b561681" id="r_a6cde40b39450043f88060a5d1b561681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a6cde40b39450043f88060a5d1b561681">SetLoopCallback</a> (const std::function&lt; void(std::chrono::milliseconds)&gt; &amp;func)</td></tr>
<tr class="separator:a6cde40b39450043f88060a5d1b561681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac560d2a54c77a7a14e11c800cea39aa6" id="r_ac560d2a54c77a7a14e11c800cea39aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#ac560d2a54c77a7a14e11c800cea39aa6">SendWebsocketMessage</a> (const std::set&lt; <a class="el" href="classNamedType.html">endpoint</a> &gt; &amp;setEndpoints, const Json::Value &amp;jsMessage)</td></tr>
<tr class="memdesc:ac560d2a54c77a7a14e11c800cea39aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a JSON formatted websocket message.  <br /></td></tr>
<tr class="separator:ac560d2a54c77a7a14e11c800cea39aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f59d0f045282b2915be6849e39776e" id="r_a32f59d0f045282b2915be6849e39776e"><td class="memItemLeft" align="right" valign="top">std::set&lt; methodpoint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a32f59d0f045282b2915be6849e39776e">GetEndpoints</a> ()</td></tr>
<tr class="memdesc:a32f59d0f045282b2915be6849e39776e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set containing all the defined Restful methodpoints.  <br /></td></tr>
<tr class="separator:a32f59d0f045282b2915be6849e39776e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38237225f38793062158719eb84813d" id="r_aa38237225f38793062158719eb84813d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#aa38237225f38793062158719eb84813d">SetStaticDirectory</a> (const std::string &amp;sDir)</td></tr>
<tr class="memdesc:aa38237225f38793062158719eb84813d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a directory to serve standard webpages from.  <br /></td></tr>
<tr class="separator:aa38237225f38793062158719eb84813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297127bf5e39299cb2570703f93b59a" id="r_a6297127bf5e39299cb2570703f93b59a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a6297127bf5e39299cb2570703f93b59a">GetStaticDirectory</a> () const</td></tr>
<tr class="memdesc:a6297127bf5e39299cb2570703f93b59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the directory that has been set to serve html web pages from.  <br /></td></tr>
<tr class="separator:a6297127bf5e39299cb2570703f93b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e3b4538b86731358ddf2c9f5b675f4" id="r_ab9e3b4538b86731358ddf2c9f5b675f4"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#ab9e3b4538b86731358ddf2c9f5b675f4">GetPort</a> () const</td></tr>
<tr class="memdesc:ab9e3b4538b86731358ddf2c9f5b675f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the port number that the server is listening on.  <br /></td></tr>
<tr class="separator:ab9e3b4538b86731358ddf2c9f5b675f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61da71a1004c6c16e86ab64c0d2c318a" id="r_a61da71a1004c6c16e86ab64c0d2c318a"><td class="memItemLeft" align="right" valign="top"><a id="a61da71a1004c6c16e86ab64c0d2c318a" name="a61da71a1004c6c16e86ab64c0d2c318a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrimeWait</b> ()</td></tr>
<tr class="memdesc:a61da71a1004c6c16e86ab64c0d2c318a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primes the server for pausing - allowing another thread to gather data before the server replies. <br /></td></tr>
<tr class="separator:a61da71a1004c6c16e86ab64c0d2c318a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af723905bd8bbb15042529bcebe615cdd" id="r_af723905bd8bbb15042529bcebe615cdd"><td class="memItemLeft" align="right" valign="top"><a id="af723905bd8bbb15042529bcebe615cdd" name="af723905bd8bbb15042529bcebe615cdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Wait</b> ()</td></tr>
<tr class="memdesc:af723905bd8bbb15042529bcebe615cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses the server thread - allowing another thread to gather data before the server replies. <br /></td></tr>
<tr class="separator:af723905bd8bbb15042529bcebe615cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba5b266f683a45bf45e203838def9dc" id="r_a4ba5b266f683a45bf45e203838def9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a4ba5b266f683a45bf45e203838def9dc">Signal</a> (const <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a> &amp;resp)</td></tr>
<tr class="memdesc:a4ba5b266f683a45bf45e203838def9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restarts a paused server thread.  <br /></td></tr>
<tr class="separator:a4ba5b266f683a45bf45e203838def9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7d0da0e4f571cb91172086b7ee3a18" id="r_a1d7d0da0e4f571cb91172086b7ee3a18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a1d7d0da0e4f571cb91172086b7ee3a18">GetSignalResponse</a> () const</td></tr>
<tr class="memdesc:a1d7d0da0e4f571cb91172086b7ee3a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the response value passed in the Signal routine.  <br /></td></tr>
<tr class="separator:a1d7d0da0e4f571cb91172086b7ee3a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d7fe5408eb59373b96aa7ba3ec4053" id="r_a57d7fe5408eb59373b96aa7ba3ec4053"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classNamedType.html">ipAddress</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a57d7fe5408eb59373b96aa7ba3ec4053">GetCurrentPeer</a> (bool bIncludePort=true) const</td></tr>
<tr class="memdesc:a57d7fe5408eb59373b96aa7ba3ec4053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ip address of the peer that sent the request currently being handled.  <br /></td></tr>
<tr class="separator:a57d7fe5408eb59373b96aa7ba3ec4053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19be1a4d4d53c5183741142c433efff" id="r_ac19be1a4d4d53c5183741142c433efff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#ac19be1a4d4d53c5183741142c433efff">GetNumberOfWebsocketConnections</a> () const</td></tr>
<tr class="memdesc:ac19be1a4d4d53c5183741142c433efff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Number Of Websocket Connections object.  <br /></td></tr>
<tr class="separator:ac19be1a4d4d53c5183741142c433efff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3ff5740d3845126aa00b0e6805abb3" id="r_a8d3ff5740d3845126aa00b0e6805abb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a8d3ff5740d3845126aa00b0e6805abb3">AddHeaders</a> (const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;mHeaders)</td></tr>
<tr class="memdesc:a8d3ff5740d3845126aa00b0e6805abb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds extra headers for the server to send on all replies.  <br /></td></tr>
<tr class="separator:a8d3ff5740d3845126aa00b0e6805abb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe8d6342565cb75f9cb1426100a4e5" id="r_a2ebe8d6342565cb75f9cb1426100a4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a2ebe8d6342565cb75f9cb1426100a4e5">RemoveHeaders</a> (const std::set&lt; <a class="el" href="classNamedType.html">headerName</a> &gt; &amp;setHeaders)</td></tr>
<tr class="memdesc:a2ebe8d6342565cb75f9cb1426100a4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes headers from the list of those to be sent by the server.  <br /></td></tr>
<tr class="separator:a2ebe8d6342565cb75f9cb1426100a4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509b8162c1a803f2c7527435b7dc0335" id="r_a509b8162c1a803f2c7527435b7dc0335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1Server.html#a509b8162c1a803f2c7527435b7dc0335">SetHeaders</a> (const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;mHeaders)</td></tr>
<tr class="memdesc:a509b8162c1a803f2c7527435b7dc0335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the headers to be sent by the server @para[in]m mHeaders a map of headerName, headerValue pairs.  <br /></td></tr>
<tr class="separator:a509b8162c1a803f2c7527435b7dc0335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2131a6573102ab1949f00d2f66b700ea" name="a2131a6573102ab1949f00d2f66b700ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2131a6573102ab1949f00d2f66b700ea">&#9670;&#160;</a></span>AddBAUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::Server::AddBAUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">userName</a> &amp;&#160;</td>
          <td class="paramname"><em>aUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">password</a> &amp;&#160;</td>
          <td class="paramname"><em>aPassword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a basic authentication user/password pair to the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aUser</td><td>the username </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPassword</td><td>the password </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool will return false if the authorization type is not set to basic or the user already exists </dd></dl>

</div>
</div>
<a id="a7678afd43a6f601283076016971cf2eb" name="a7678afd43a6f601283076016971cf2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7678afd43a6f601283076016971cf2eb">&#9670;&#160;</a></span>AddEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::Server::AddEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">httpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>theEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a>(const query &amp;, const std::vector&lt; <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> &gt; &amp;, const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const <a class="el" href="classNamedType.html">userName</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseThread</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a callback handler for an methodpoint </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theEndpoint</td><td>a pair definining the HTTP method and methodpoint address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>std::function that defines the callback function.The function is passed the query data, std::vector&lt;partData&gt; (for a PUT,PATCH or POST) the methodpoint and the userName if any. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bUseThread</td><td>if false then the callback will be called in the server thread The function should return a response which will be sent back to the client </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true on success </dd></dl>

</div>
</div>
<a id="a8d3ff5740d3845126aa00b0e6805abb3" name="a8d3ff5740d3845126aa00b0e6805abb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3ff5740d3845126aa00b0e6805abb3">&#9670;&#160;</a></span>AddHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::AddHeaders </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mHeaders</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds extra headers for the server to send on all replies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mHeaders</td><td>a map of headerName, headerValue pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if a headerName already exists in list of those to be sent then the value sent is overwritten by this function </dd>
<dd>
Content-Type and Content-Length are always sent and cannot be overwritten </dd></dl>

</div>
</div>
<a id="a5b2eb768de72271b9137fb27c4bedfe6" name="a5b2eb768de72271b9137fb27c4bedfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2eb768de72271b9137fb27c4bedfe6">&#9670;&#160;</a></span>AddNotFoundCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::AddNotFoundCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a>(const <a class="el" href="classNamedType.html">httpMethod</a> &amp;, const query &amp;, const std::vector&lt; <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> &gt; &amp;, const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const <a class="el" href="classNamedType.html">userName</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function to be called everytime a client attempts to connect to a methodpoint that is not defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>the function to be called. The function is passed the query data, std::vector&lt;partData&gt; (for a PUT,PATCH or POST) the methodpoint and the userName if any. The function should return a response which will be sent back to the client</td></tr>
  </table>
  </dd>
</dl>
<p>Stops the server </p>

</div>
</div>
<a id="ad62d58452457a7a785ada7a61067d646" name="ad62d58452457a7a785ada7a61067d646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62d58452457a7a785ada7a61067d646">&#9670;&#160;</a></span>AddWebsocketEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::Server::AddWebsocketEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>theEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const query &amp;, const <a class="el" href="classNamedType.html">userName</a> &amp;, const <a class="el" href="classNamedType.html">ipAddress</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>funcAuthentication</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const Json::Value &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>funcMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classNamedType.html">endpoint</a> &amp;, const <a class="el" href="classNamedType.html">ipAddress</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>funcClose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an enpoint that a websocket client can connect to along with callback functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theEndpoint</td><td>the address the client is allowed to connect to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">funcAuthentication</td><td>a function that will be called when a client first attempts to connect to the methodpoint. The function is passed the methodpoint address, a map of any query paramaters in the url, the username that has been passed by the websocket and the ip address of the connecting client. The function should return true to allow the connection to continue and false to close it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">funcMessage</td><td>a function that is called everytime the client sends a websocket message to the server. The function is passed the methodpoint address and the message passed (as Json). The function should return true to allow the connection to continue and false to close it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">funcClose</td><td>a function that is called when the client closes the websocket connection. The function is passed the methodpoint address and the client ip address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the websocket methodpoint was added </dd></dl>

</div>
</div>
<a id="af7b0d58606adac7831bfd720578b296d" name="af7b0d58606adac7831bfd720578b296d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b0d58606adac7831bfd720578b296d">&#9670;&#160;</a></span>DeleteBAUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::Server::DeleteBAUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">userName</a> &amp;&#160;</td>
          <td class="paramname"><em>aUser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a user from basic authentication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aUser</td><td>the username </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool will return false if the authorization type is not set to basic </dd></dl>

</div>
</div>
<a id="a856f15350b38e6b51606a4a592cc7367" name="a856f15350b38e6b51606a4a592cc7367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856f15350b38e6b51606a4a592cc7367">&#9670;&#160;</a></span>DeleteEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::Server::DeleteEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">httpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>theEndpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a callback handler for an methodpoint </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theEndpoint</td><td>a pair definining the HTTP method and methodpoint address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true on success </dd></dl>

</div>
</div>
<a id="ae48d416c881e8cccd31f6b6bcd243f31" name="ae48d416c881e8cccd31f6b6bcd243f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48d416c881e8cccd31f6b6bcd243f31">&#9670;&#160;</a></span>GetAccessControlList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; pml::restgoose::Server::GetAccessControlList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the access control list. </p>
<dl class="section return"><dt>Returns</dt><dd>Comma separated acces control list </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the form is -[not allowed],+[allowed] </dd></dl>

</div>
</div>
<a id="a57d7fe5408eb59373b96aa7ba3ec4053" name="a57d7fe5408eb59373b96aa7ba3ec4053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d7fe5408eb59373b96aa7ba3ec4053">&#9670;&#160;</a></span>GetCurrentPeer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classNamedType.html">ipAddress</a> &amp; pml::restgoose::Server::GetCurrentPeer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludePort</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ip address of the peer that sent the request currently being handled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bIncludePort</td><td>if true then the port number is included else just the ip address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is address is only valid whilst handling an api endpoint callback </dd></dl>

</div>
</div>
<a id="a32f59d0f045282b2915be6849e39776e" name="a32f59d0f045282b2915be6849e39776e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f59d0f045282b2915be6849e39776e">&#9670;&#160;</a></span>GetEndpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; methodpoint &gt; pml::restgoose::Server::GetEndpoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set containing all the defined Restful methodpoints. </p>
<dl class="section return"><dt>Returns</dt><dd>set&lt;methodpoint&gt; the methodpoints </dd></dl>

</div>
</div>
<a id="ac19be1a4d4d53c5183741142c433efff" name="ac19be1a4d4d53c5183741142c433efff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19be1a4d4d53c5183741142c433efff">&#9670;&#160;</a></span>GetNumberOfWebsocketConnections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pml::restgoose::Server::GetNumberOfWebsocketConnections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Number Of Websocket Connections object. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t the number of websocket connections </dd></dl>

</div>
</div>
<a id="ab9e3b4538b86731358ddf2c9f5b675f4" name="ab9e3b4538b86731358ddf2c9f5b675f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e3b4538b86731358ddf2c9f5b675f4">&#9670;&#160;</a></span>GetPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long pml::restgoose::Server::GetPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the port number that the server is listening on. </p>
<dl class="section return"><dt>Returns</dt><dd>unsigned long the port </dd></dl>

</div>
</div>
<a id="a1d7d0da0e4f571cb91172086b7ee3a18" name="a1d7d0da0e4f571cb91172086b7ee3a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7d0da0e4f571cb91172086b7ee3a18">&#9670;&#160;</a></span>GetSignalResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a> &amp; pml::restgoose::Server::GetSignalResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the response value passed in the Signal routine. </p>
<dl class="section return"><dt>Returns</dt><dd>response the data sent from the signalling thread </dd></dl>

</div>
</div>
<a id="a6297127bf5e39299cb2570703f93b59a" name="a6297127bf5e39299cb2570703f93b59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297127bf5e39299cb2570703f93b59a">&#9670;&#160;</a></span>GetStaticDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; pml::restgoose::Server::GetStaticDirectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the directory that has been set to serve html web pages from. </p>
<dl class="section return"><dt>Returns</dt><dd>string the full path </dd></dl>

</div>
</div>
<a id="a172f5f57f9a90adb3cc8c001d2311774" name="a172f5f57f9a90adb3cc8c001d2311774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172f5f57f9a90adb3cc8c001d2311774">&#9670;&#160;</a></span>Init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::Server::Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">ipAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>apiRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableWebsocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSendPings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the ip address of the interface to run on (pass 0.0.0.0 to listen on all interfaces) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nPort</td><td>the TCP/IP port number to listen on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">apiRoot</td><td>the relative URL that is the base of the API tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnableWebsocket</td><td>set to true to act as a websocket server as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the server has been successufully intialised </dd></dl>

</div>
</div>
<a id="a17412c44f2147d64c22340dccf2b6aa3" name="a17412c44f2147d64c22340dccf2b6aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17412c44f2147d64c22340dccf2b6aa3">&#9670;&#160;</a></span>Init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::Server::Init </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>ca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">ipAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>apiRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableWebsocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSendPings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ca</td><td>the full path and file name to a TLS certificate authorirty </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cert</td><td>the full path and file name to a TLS certificate if one is being used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the full path and file name to a TLC key if one is being used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the ip address of the interface to run on (pass 0.0.0.0 to listen on all interfaces) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nPort</td><td>the TCP/IP port number to listen on if set to 0 then will use 80 for http and 443 for https </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">apiRoot</td><td>the relative URL that is the base of the API tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnableWebsocket</td><td>set to true to act as a websocket server as well </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bSendPings</td><td>set to true for the server to send websocket pings to the clients </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the server has been successufully intialised </dd></dl>

</div>
</div>
<a id="a76c8f884ad0cfbdd36a064d8fce8d7a4" name="a76c8f884ad0cfbdd36a064d8fce8d7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c8f884ad0cfbdd36a064d8fce8d7a4">&#9670;&#160;</a></span>Init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::Server::Init </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">ipAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>nPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>apiRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableWebsocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSendPings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert</td><td>the full path and file name to a TLS certificate if one is being used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the full path and file name to a TLC key if one is being used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the ip address of the interface to run on (pass 0.0.0.0 to listen on all interfaces) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nPort</td><td>the TCP/IP port number to listen on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">apiRoot</td><td>the relative URL that is the base of the API tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnableWebsocket</td><td>set to true to act as a websocket server as well </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bSendPings</td><td>set to true for the server to send websocket pings to the clients </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if the server has been successufully intialised </dd></dl>

</div>
</div>
<a id="a2ebe8d6342565cb75f9cb1426100a4e5" name="a2ebe8d6342565cb75f9cb1426100a4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebe8d6342565cb75f9cb1426100a4e5">&#9670;&#160;</a></span>RemoveHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::RemoveHeaders </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classNamedType.html">headerName</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>setHeaders</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes headers from the list of those to be sent by the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">setHeaders</td><td>a set of headerNames to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Content-Type and Content-Length are always sent and cannot be removed </dd></dl>

</div>
</div>
<a id="ab82520a2dd424c185dec9dc6771ee063" name="ab82520a2dd424c185dec9dc6771ee063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82520a2dd424c185dec9dc6771ee063">&#9670;&#160;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::Run </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bThread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds(100)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the webserver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bThread</td><td>if true will run in a separate thread, if false will run in main thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nTimeoutms</td><td>the time in milliseconds to wait for a mongoose event to happen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac560d2a54c77a7a14e11c800cea39aa6" name="ac560d2a54c77a7a14e11c800cea39aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac560d2a54c77a7a14e11c800cea39aa6">&#9670;&#160;</a></span>SendWebsocketMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SendWebsocketMessage </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classNamedType.html">endpoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>setEndpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>jsMessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a JSON formatted websocket message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">setEnpoints</td><td>the set of websocket methodpoints that the message should be sent to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jsMessage</td><td>the message to send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a427545c00df56cfa22c9dfbf72f816b0" name="a427545c00df56cfa22c9dfbf72f816b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427545c00df56cfa22c9dfbf72f816b0">&#9670;&#160;</a></span>SetAccessControlList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetAccessControlList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sAcl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the access control list for the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sAcl</td><td>the access control list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the form is -[not allowed],+[allowed] </dd></dl>

</div>
</div>
<a id="aa67c7c51c7a9da46277d4fe5ea624110" name="aa67c7c51c7a9da46277d4fe5ea624110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67c7c51c7a9da46277d4fe5ea624110">&#9670;&#160;</a></span>SetAuthorizationTypeBasic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetAuthorizationTypeBasic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">userName</a> &amp;&#160;</td>
          <td class="paramname"><em>aUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">password</a> &amp;&#160;</td>
          <td class="paramname"><em>aPassword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the authorization type to basic authentication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aUser</td><td>a user name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPassword</td><td>the password that authenticates the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e46072061d99f904755975c84739e6a" name="a9e46072061d99f904755975c84739e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e46072061d99f904755975c84739e6a">&#9670;&#160;</a></span>SetAuthorizationTypeBearer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetAuthorizationTypeBearer </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const methodpoint &amp;, const std::string &amp;theToken)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a>(const <a class="el" href="classNamedType.html">endpoint</a> &amp;, bool)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callbackHandleNotAuthorized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAuthenticateWebsocketsViaQuery</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the authorization type to expect a bearer token in the Authorization header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>a callback function that should inspect the token and return true if authorization is allowed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bAuthenticateWebsocketsViaQuery</td><td>if true then, for websocket connections, the bearer token is expected to be passed as a query param in the connecting websocket url (e.g. wss://127.0.0.1:/ws/api?jwt=923834aa9q3....). If false then the token must be passed as the first message from the client to the server </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a509b8162c1a803f2c7527435b7dc0335" name="a509b8162c1a803f2c7527435b7dc0335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509b8162c1a803f2c7527435b7dc0335">&#9670;&#160;</a></span>SetHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetHeaders </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mHeaders</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the headers to be sent by the server @para[in]m mHeaders a map of headerName, headerValue pairs. </p>
<dl class="section note"><dt>Note</dt><dd>Content-Type and Content-Length are always sent </dd></dl>

</div>
</div>
<a id="aee7d8cace41bf8ed40aa7ad4f4b6dfb6" name="aee7d8cace41bf8ed40aa7ad4f4b6dfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7d8cace41bf8ed40aa7ad4f4b6dfb6">&#9670;&#160;</a></span>SetInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">ipAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>nPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interface and port to run on. If the webserver is already running this will have no effect until it is restarted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the ip address of the interface to run on (pass 0.0.0.0 to listen on all interfaces) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nPort</td><td>the TCP/IP port number to listen on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cde40b39450043f88060a5d1b561681" name="a6cde40b39450043f88060a5d1b561681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cde40b39450043f88060a5d1b561681">&#9670;&#160;</a></span>SetLoopCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetLoopCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(std::chrono::milliseconds)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the function that will be called every time the poll function times out or an event happens </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>the function to call. It will be passed one argument, the number of milliseconds since it was last called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05a8695e1ce0da3d8ecdd32162e48319" name="a05a8695e1ce0da3d8ecdd32162e48319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a8695e1ce0da3d8ecdd32162e48319">&#9670;&#160;</a></span>SetMaxConnections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetMaxConnections </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of connections the server will accept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nMax</td><td>the maximum number of connections </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa38237225f38793062158719eb84813d" name="aa38237225f38793062158719eb84813d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38237225f38793062158719eb84813d">&#9670;&#160;</a></span>SetStaticDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetStaticDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a directory to serve standard webpages from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sDir</td><td>a full path to the directory that the static html web pages live in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40b1c291c4960827a3655f99efb21030" name="a40b1c291c4960827a3655f99efb21030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b1c291c4960827a3655f99efb21030">&#9670;&#160;</a></span>SetUnprotectedEndpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::SetUnprotectedEndpoints </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; methodpoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>setUnprotected</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a set of methodpoints that do not need to be authenticated (e.g. to show an initial login page) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">setUnprotected</td><td>a set of method,endpoint pairs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ba5b266f683a45bf45e203838def9dc" name="a4ba5b266f683a45bf45e203838def9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba5b266f683a45bf45e203838def9dc">&#9670;&#160;</a></span>Signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::Server::Signal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpml_1_1restgoose_1_1response.html">response</a> &amp;&#160;</td>
          <td class="paramname"><em>resp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restarts a paused server thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">resp</td><td>a response object containing data from the signalling thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this must be called from another thread </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/oem/Restgoose/include/<a class="el" href="RestGoose_8h_source.html">RestGoose.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>pml</b></li><li class="navelem"><b>restgoose</b></li><li class="navelem"><a class="el" href="classpml_1_1restgoose_1_1Server.html">Server</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
