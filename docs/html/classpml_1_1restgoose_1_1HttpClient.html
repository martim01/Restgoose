<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Restgoose: pml::restgoose::HttpClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Restgoose
   </div>
   <div id="projectbrief">RESTful Server and Client + Websockets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classpml_1_1restgoose_1_1HttpClient.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpml_1_1restgoose_1_1HttpClient-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pml::restgoose::HttpClient Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class to connect to HTTP server.  
 <a href="classpml_1_1restgoose_1_1HttpClient.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="httpclient_8h_source.html">httpclient.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a75c251f59205c422fc83054970a7c6" id="r_a6a75c251f59205c422fc83054970a7c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a6a75c251f59205c422fc83054970a7c6">HttpClient</a> (const <a class="el" href="classNamedType.html">httpMethod</a> &amp;method, const <a class="el" href="classNamedType.html">endpoint</a> &amp;target, const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;mExtraHeaders={}, clientResponse::enumResponse eResponse=clientResponse::enumResponse::kAuto)</td></tr>
<tr class="memdesc:a6a75c251f59205c422fc83054970a7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that does not send any data to the server. Usually used for GET, DELETE or OPTIONS.  <br /></td></tr>
<tr class="separator:a6a75c251f59205c422fc83054970a7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd5c2a9a1e6a6fb6885871be8c508c6" id="r_acbd5c2a9a1e6a6fb6885871be8c508c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#acbd5c2a9a1e6a6fb6885871be8c508c6">HttpClient</a> (const <a class="el" href="classNamedType.html">httpMethod</a> &amp;method, const <a class="el" href="classNamedType.html">endpoint</a> &amp;target, const Json::Value &amp;jsData, const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;mExtraHeaders={}, clientResponse::enumResponse eResponse=clientResponse::enumResponse::kAuto)</td></tr>
<tr class="memdesc:acbd5c2a9a1e6a6fb6885871be8c508c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that sends JSON formatted data to the server.  <br /></td></tr>
<tr class="separator:acbd5c2a9a1e6a6fb6885871be8c508c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dba66b55ae2706733b8403e39c222c2" id="r_a1dba66b55ae2706733b8403e39c222c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a1dba66b55ae2706733b8403e39c222c2">HttpClient</a> (const <a class="el" href="classNamedType.html">httpMethod</a> &amp;method, const <a class="el" href="classNamedType.html">endpoint</a> &amp;target, const <a class="el" href="classNamedType.html">textData</a> &amp;data, const <a class="el" href="classNamedType.html">headerValue</a> &amp;contentType=<a class="el" href="classNamedType.html">headerValue</a>(&quot;text/plain&quot;), const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;mExtraHeaders={}, clientResponse::enumResponse eResponse=clientResponse::enumResponse::kAuto)</td></tr>
<tr class="memdesc:a1dba66b55ae2706733b8403e39c222c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that sends arbitrary formatted data to the server.  <br /></td></tr>
<tr class="separator:a1dba66b55ae2706733b8403e39c222c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0336bb722be8822cd66b0858f93c9f" id="r_aeb0336bb722be8822cd66b0858f93c9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#aeb0336bb722be8822cd66b0858f93c9f">HttpClient</a> (const <a class="el" href="classNamedType.html">httpMethod</a> &amp;method, const <a class="el" href="classNamedType.html">endpoint</a> &amp;target, const <a class="el" href="classNamedType.html">textData</a> &amp;filename, const std::filesystem::path &amp;filepath, const <a class="el" href="classNamedType.html">headerValue</a> &amp;contentType=<a class="el" href="classNamedType.html">headerValue</a>(&quot;application/octet-stream&quot;), const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;mExtraHeaders={}, clientResponse::enumResponse eResponse=clientResponse::enumResponse::kAuto)</td></tr>
<tr class="memdesc:aeb0336bb722be8822cd66b0858f93c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that will upload a file to the server.  <br /></td></tr>
<tr class="separator:aeb0336bb722be8822cd66b0858f93c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d368472bb3fe0b04454e595b50b601" id="r_a58d368472bb3fe0b04454e595b50b601"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a58d368472bb3fe0b04454e595b50b601">HttpClient</a> (const <a class="el" href="classNamedType.html">httpMethod</a> &amp;method, const <a class="el" href="classNamedType.html">endpoint</a> &amp;target, const std::vector&lt; <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> &gt; &amp;vData, const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;mExtraHeaders={}, clientResponse::enumResponse eResponse=clientResponse::enumResponse::kAuto)</td></tr>
<tr class="memdesc:a58d368472bb3fe0b04454e595b50b601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that sends multipart/form data to the server.  <br /></td></tr>
<tr class="separator:a58d368472bb3fe0b04454e595b50b601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfc2f3684a1f3144b2b21b8f111d48e" id="r_a8cfc2f3684a1f3144b2b21b8f111d48e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a8cfc2f3684a1f3144b2b21b8f111d48e">Run</a> (const std::chrono::milliseconds &amp;connectionTimeout=std::chrono::milliseconds(5000), const std::chrono::milliseconds &amp;processTimeout=std::chrono::milliseconds(0)) const</td></tr>
<tr class="memdesc:a8cfc2f3684a1f3144b2b21b8f111d48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function that attempts to connect to the server, send any data and retrieve any response. This is a synchronous function.  <br /></td></tr>
<tr class="separator:a8cfc2f3684a1f3144b2b21b8f111d48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbe6ab7a6db4b0d03ce443105117aa6" id="r_a3cbe6ab7a6db4b0d03ce443105117aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a3cbe6ab7a6db4b0d03ce443105117aa6">Run</a> (const std::function&lt; void(const <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> &amp;, unsigned int, const std::string &amp;)&gt; &amp;pCallback, unsigned int nRunId, const std::string &amp;sUserData, const std::chrono::milliseconds &amp;connectionTimeout=std::chrono::milliseconds(5000), const std::chrono::milliseconds &amp;processTimeout=std::chrono::milliseconds(0), const std::chrono::milliseconds &amp;delay=std::chrono::milliseconds(0)) const</td></tr>
<tr class="memdesc:a3cbe6ab7a6db4b0d03ce443105117aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function that attempts to connect to the server, send any data and retrieve any response. This is an asynchronous function.  <br /></td></tr>
<tr class="separator:a3cbe6ab7a6db4b0d03ce443105117aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f15a584e062a0a3d878a9e7cc97306" id="r_a81f15a584e062a0a3d878a9e7cc97306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a81f15a584e062a0a3d878a9e7cc97306">Run</a> (const std::function&lt; void(const <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> &amp;, unsigned int)&gt; &amp;pCallback, unsigned int nRunId, const std::chrono::milliseconds &amp;connectionTimeout=std::chrono::milliseconds(5000), const std::chrono::milliseconds &amp;processTimeout=std::chrono::milliseconds(0), const std::chrono::milliseconds &amp;delay=std::chrono::milliseconds(0)) const</td></tr>
<tr class="memdesc:a81f15a584e062a0a3d878a9e7cc97306"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function that attempts to connect to the server, send any data and retrieve any response. This is an asynchronous function.  <br /></td></tr>
<tr class="separator:a81f15a584e062a0a3d878a9e7cc97306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dff210e334b070569f9e8d214e1029f" id="r_a0dff210e334b070569f9e8d214e1029f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a0dff210e334b070569f9e8d214e1029f">SetUploadProgressCallback</a> (const std::function&lt; void(unsigned long, unsigned long)&gt; &amp;pCallback) const</td></tr>
<tr class="memdesc:a0dff210e334b070569f9e8d214e1029f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback function that is called every time a "chunk" of data is sent to the server. This is useful for showing the progress of large uploads.  <br /></td></tr>
<tr class="separator:a0dff210e334b070569f9e8d214e1029f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af631133be8a00e35ac1a09b1cf64f683" id="r_af631133be8a00e35ac1a09b1cf64f683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#af631133be8a00e35ac1a09b1cf64f683">SetDownloadProgressCallback</a> (const std::function&lt; void(unsigned long, unsigned long)&gt; &amp;pCallback) const</td></tr>
<tr class="memdesc:af631133be8a00e35ac1a09b1cf64f683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback function that is called every time a "chunk" of data is sent from the server. This is useful for showing the progress of large downloads.  <br /></td></tr>
<tr class="separator:af631133be8a00e35ac1a09b1cf64f683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775a5f45e339a661e0303d9ad2b8dbb5" id="r_a775a5f45e339a661e0303d9ad2b8dbb5"><td class="memItemLeft" align="right" valign="top"><a id="a775a5f45e339a661e0303d9ad2b8dbb5" name="a775a5f45e339a661e0303d9ad2b8dbb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Cancel</b> () const</td></tr>
<tr class="memdesc:a775a5f45e339a661e0303d9ad2b8dbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a running procedure. <br /></td></tr>
<tr class="separator:a775a5f45e339a661e0303d9ad2b8dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b1d1cfeeacf0b28cdabca7fd2a78a0" id="r_a54b1d1cfeeacf0b28cdabca7fd2a78a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a54b1d1cfeeacf0b28cdabca7fd2a78a0">UseProxy</a> (const std::string &amp;proxy)</td></tr>
<tr class="memdesc:a54b1d1cfeeacf0b28cdabca7fd2a78a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the url of a proxy to use for the connection.  <br /></td></tr>
<tr class="separator:a54b1d1cfeeacf0b28cdabca7fd2a78a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6062051f9d0e1f74ba96617d241292" id="r_a1e6062051f9d0e1f74ba96617d241292"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a1e6062051f9d0e1f74ba96617d241292">SetBasicAuthentication</a> (const <a class="el" href="classNamedType.html">userName</a> &amp;user, const <a class="el" href="classNamedType.html">password</a> &amp;pass) const</td></tr>
<tr class="memdesc:a1e6062051f9d0e1f74ba96617d241292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use basic authenitication for the connection.  <br /></td></tr>
<tr class="separator:a1e6062051f9d0e1f74ba96617d241292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9906706a3a767131b6f0a54363b8e5d1" id="r_a9906706a3a767131b6f0a54363b8e5d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a9906706a3a767131b6f0a54363b8e5d1">SetBearerAuthentication</a> (const std::string &amp;sToken) const</td></tr>
<tr class="memdesc:a9906706a3a767131b6f0a54363b8e5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">User Bearer Authentication for the connetion.  <br /></td></tr>
<tr class="separator:a9906706a3a767131b6f0a54363b8e5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429ce7c1bfd2b882448776a1675c03c1" id="r_a429ce7c1bfd2b882448776a1675c03c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a429ce7c1bfd2b882448776a1675c03c1">SetCertificateAuthority</a> (const std::filesystem::path &amp;ca) const</td></tr>
<tr class="memdesc:a429ce7c1bfd2b882448776a1675c03c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file location of the certificate authority file to use (if any)  <br /></td></tr>
<tr class="separator:a429ce7c1bfd2b882448776a1675c03c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe99f7b4348e52972faeba7c5a70a165" id="r_afe99f7b4348e52972faeba7c5a70a165"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#afe99f7b4348e52972faeba7c5a70a165">SetClientCertificate</a> (const std::filesystem::path &amp;cert, const std::filesystem::path &amp;key) const</td></tr>
<tr class="memdesc:afe99f7b4348e52972faeba7c5a70a165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the client certificate to use if server requires authentication.  <br /></td></tr>
<tr class="separator:afe99f7b4348e52972faeba7c5a70a165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d92bde9e242b605c51ddd39d53c7dda" id="r_a2d92bde9e242b605c51ddd39d53c7dda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a2d92bde9e242b605c51ddd39d53c7dda">SetMethod</a> (const <a class="el" href="classNamedType.html">httpMethod</a> &amp;method) const</td></tr>
<tr class="memdesc:a2d92bde9e242b605c51ddd39d53c7dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the HTTP method to use.  <br /></td></tr>
<tr class="separator:a2d92bde9e242b605c51ddd39d53c7dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712480b865b942dfbe72b412e4f489e8" id="r_a712480b865b942dfbe72b412e4f489e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a712480b865b942dfbe72b412e4f489e8">SetEndpoint</a> (const <a class="el" href="classNamedType.html">endpoint</a> &amp;target) const</td></tr>
<tr class="memdesc:a712480b865b942dfbe72b412e4f489e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the URL to connect to.  <br /></td></tr>
<tr class="separator:a712480b865b942dfbe72b412e4f489e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac64e5d4b2d3e9709de766db14d12d22" id="r_aac64e5d4b2d3e9709de766db14d12d22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#aac64e5d4b2d3e9709de766db14d12d22">SetData</a> (const Json::Value &amp;jsData) const</td></tr>
<tr class="memdesc:aac64e5d4b2d3e9709de766db14d12d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data to send (if a POST/PULL/PUT request) in JSON format.  <br /></td></tr>
<tr class="separator:aac64e5d4b2d3e9709de766db14d12d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa20d184fba981fe79e378eabd7c250" id="r_a7aa20d184fba981fe79e378eabd7c250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a7aa20d184fba981fe79e378eabd7c250">SetData</a> (const <a class="el" href="classNamedType.html">textData</a> &amp;data) const</td></tr>
<tr class="memdesc:a7aa20d184fba981fe79e378eabd7c250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data to send (if a POST/PULL/PUT request) in plain/text format.  <br /></td></tr>
<tr class="separator:a7aa20d184fba981fe79e378eabd7c250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551d5ffa31057fc885b0f5dd1561e345" id="r_a551d5ffa31057fc885b0f5dd1561e345"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a551d5ffa31057fc885b0f5dd1561e345">SetFile</a> (const <a class="el" href="classNamedType.html">textData</a> &amp;filename, const std::filesystem::path &amp;filepath) const</td></tr>
<tr class="memdesc:a551d5ffa31057fc885b0f5dd1561e345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file to upload (if a POST/PULL/PUT request)  <br /></td></tr>
<tr class="separator:a551d5ffa31057fc885b0f5dd1561e345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769fb2159fc0a25222d0d7523fe29d36" id="r_a769fb2159fc0a25222d0d7523fe29d36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a769fb2159fc0a25222d0d7523fe29d36">SetPartData</a> (const std::vector&lt; <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> &gt; &amp;vData) const</td></tr>
<tr class="memdesc:a769fb2159fc0a25222d0d7523fe29d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the multipart data to send (if a POST/PULL/PUT request)  <br /></td></tr>
<tr class="separator:a769fb2159fc0a25222d0d7523fe29d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbe8032c3cffa43bf79d92d363c200d" id="r_a5fbe8032c3cffa43bf79d92d363c200d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a5fbe8032c3cffa43bf79d92d363c200d">AddHeaders</a> (const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;mHeaders) const</td></tr>
<tr class="memdesc:a5fbe8032c3cffa43bf79d92d363c200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add HTTP headers to send.  <br /></td></tr>
<tr class="separator:a5fbe8032c3cffa43bf79d92d363c200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131bd9848e5154efddfa8fcdce766027" id="r_a131bd9848e5154efddfa8fcdce766027"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html#a131bd9848e5154efddfa8fcdce766027">SetExpectedResponse</a> (const clientResponse::enumResponse eResponse) const</td></tr>
<tr class="memdesc:a131bd9848e5154efddfa8fcdce766027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the expected format of the response from the server.  <br /></td></tr>
<tr class="separator:a131bd9848e5154efddfa8fcdce766027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to connect to HTTP server. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a75c251f59205c422fc83054970a7c6" name="a6a75c251f59205c422fc83054970a7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a75c251f59205c422fc83054970a7c6">&#9670;&#160;</a></span>HttpClient() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pml::restgoose::HttpClient::HttpClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">httpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mExtraHeaders</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clientResponse::enumResponse&#160;</td>
          <td class="paramname"><em>eResponse</em> = <code>clientResponse::enumResponse::kAuto</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that does not send any data to the server. Usually used for GET, DELETE or OPTIONS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>the HTTP action - one of GET, POST, PUT, PATCH, DELETE, OPTIONS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the absolute url to connect to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mExtraHeaders</td><td>map of extra headers to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eResponse</td><td>one of clientResponse::enumResponse::TEXT, FILE or AUTO, decides whether the response data should be saved to a file or stored in the <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> data variable. If set to AUTO then the content-type header is looked at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbd5c2a9a1e6a6fb6885871be8c508c6" name="acbd5c2a9a1e6a6fb6885871be8c508c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd5c2a9a1e6a6fb6885871be8c508c6">&#9670;&#160;</a></span>HttpClient() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pml::restgoose::HttpClient::HttpClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">httpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>jsData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mExtraHeaders</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clientResponse::enumResponse&#160;</td>
          <td class="paramname"><em>eResponse</em> = <code>clientResponse::enumResponse::kAuto</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that sends JSON formatted data to the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>the HTTP action - one of POST, PUT, PATCH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the absolute url to connect to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jsData</td><td>the data to send to the server in JSON format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mExtraHeaders</td><td>map of extra headers to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eResponse</td><td>one of clientResponse::enumResponse::TEXT, FILE or AUTO, decides whether the response data should be saved to a file or stored in the <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> data variable. If set to AUTO then the content-type header is looked at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dba66b55ae2706733b8403e39c222c2" name="a1dba66b55ae2706733b8403e39c222c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dba66b55ae2706733b8403e39c222c2">&#9670;&#160;</a></span>HttpClient() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pml::restgoose::HttpClient::HttpClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">httpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">textData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">headerValue</a> &amp;&#160;</td>
          <td class="paramname"><em>contentType</em> = <code><a class="el" href="classNamedType.html">headerValue</a>(&quot;text/plain&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mExtraHeaders</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clientResponse::enumResponse&#160;</td>
          <td class="paramname"><em>eResponse</em> = <code>clientResponse::enumResponse::kAuto</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that sends arbitrary formatted data to the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>the HTTP action - one of POST, PUT, PATCh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the absolute url to connect to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data to send to the server </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contentType</td><td>the media type of the data being sent to the server </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mExtraHeaders</td><td>map of extra headers to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eResponse</td><td>one of clientResponse::enumResponse::TEXT, FILE or AUTO, decides whether the response data should be saved to a file or stored in the <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> data variable. If set to AUTO then the content-type header is looked at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb0336bb722be8822cd66b0858f93c9f" name="aeb0336bb722be8822cd66b0858f93c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0336bb722be8822cd66b0858f93c9f">&#9670;&#160;</a></span>HttpClient() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pml::restgoose::HttpClient::HttpClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">httpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">textData</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">headerValue</a> &amp;&#160;</td>
          <td class="paramname"><em>contentType</em> = <code><a class="el" href="classNamedType.html">headerValue</a>(&quot;application/octet-stream&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mExtraHeaders</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clientResponse::enumResponse&#160;</td>
          <td class="paramname"><em>eResponse</em> = <code>clientResponse::enumResponse::kAuto</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that will upload a file to the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>the HTTP action - one of POST, PUT, PATCH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the absolute url to connect to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the name of the file being sent to the server </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>the location of the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contentType</td><td>the media type of the data being sent to the server </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mExtraHeaders</td><td>map of extra headers to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eResponse</td><td>one of clientResponse::enumResponse::TEXT, FILE or AUTO, decides whether the response data should be saved to a file or stored in the <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> data variable. If set to AUTO then the content-type header is looked at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d368472bb3fe0b04454e595b50b601" name="a58d368472bb3fe0b04454e595b50b601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d368472bb3fe0b04454e595b50b601">&#9670;&#160;</a></span>HttpClient() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pml::restgoose::HttpClient::HttpClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">httpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mExtraHeaders</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clientResponse::enumResponse&#160;</td>
          <td class="paramname"><em>eResponse</em> = <code>clientResponse::enumResponse::kAuto</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor - creates an <a class="el" href="classpml_1_1restgoose_1_1HttpClient.html" title="Class to connect to HTTP server.">HttpClient</a> object that sends multipart/form data to the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>the HTTP action - one of POST, PUT, PATCH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the absolute url to connect to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vData</td><td>vector of <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> objects that define the multipart data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contentType</td><td>the media type of the data being sent to the server </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mExtraHeaders</td><td>map of extra headers to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eResponse</td><td>one of clientResponse::enumResponse::TEXT, FILE or AUTO, decides whether the response data should be saved to a file or stored in the <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> data variable. If set to AUTO then the content-type header is looked at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5fbe8032c3cffa43bf79d92d363c200d" name="a5fbe8032c3cffa43bf79d92d363c200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbe8032c3cffa43bf79d92d363c200d">&#9670;&#160;</a></span>AddHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::AddHeaders </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classNamedType.html">headerName</a>, <a class="el" href="classNamedType.html">headerValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mHeaders</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add HTTP headers to send. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mHeaders</td><td>a map of header name, header value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback funtion </dd></dl>

</div>
</div>
<a id="a8cfc2f3684a1f3144b2b21b8f111d48e" name="a8cfc2f3684a1f3144b2b21b8f111d48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfc2f3684a1f3144b2b21b8f111d48e">&#9670;&#160;</a></span>Run() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> &amp; pml::restgoose::HttpClient::Run </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>connectionTimeout</em> = <code>std::chrono::milliseconds(5000)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>processTimeout</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function that attempts to connect to the server, send any data and retrieve any response. This is a synchronous function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionTimeout</td><td>the amount of time to wait for a connection to the server to be accepted before giving up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">processTimeout</td><td>the amount of time to wait for the whole connect, send, receive procedure to take place. If set to 0 then the timeout is ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> a <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> object containing the HTTP repsonse code and any data sent from the server </dd></dl>

</div>
</div>
<a id="a81f15a584e062a0a3d878a9e7cc97306" name="a81f15a584e062a0a3d878a9e7cc97306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f15a584e062a0a3d878a9e7cc97306">&#9670;&#160;</a></span>Run() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::HttpClient::Run </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> &amp;, unsigned int)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nRunId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>connectionTimeout</em> = <code>std::chrono::milliseconds(5000)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>processTimeout</em> = <code>std::chrono::milliseconds(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>delay</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function that attempts to connect to the server, send any data and retrieve any response. This is an asynchronous function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCallback</td><td>a function to call when the procedure is complete, its arguments are a <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> object containing the repsonse from the server and an unsigned int containing the value passed in nRunId </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nRunId</td><td>a user defined identifier that will be passed to pCallback when it is called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionTimeout</td><td>the amount of time to wait for a connection to the server to be accepted before giving up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">processTimeout</td><td>the amount of time to wait for the whole connect, send, receive procedure to take place. If set to 0 then the timeout is ignored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>the amount of time to wait before running the function. This wait time may be longer depending on thread allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> a <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> object containing the HTTP repsonse code and any data sent from the server </dd></dl>

</div>
</div>
<a id="a3cbe6ab7a6db4b0d03ce443105117aa6" name="a3cbe6ab7a6db4b0d03ce443105117aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbe6ab7a6db4b0d03ce443105117aa6">&#9670;&#160;</a></span>Run() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::HttpClient::Run </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> &amp;, unsigned int, const std::string &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nRunId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>connectionTimeout</em> = <code>std::chrono::milliseconds(5000)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>processTimeout</em> = <code>std::chrono::milliseconds(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>delay</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function that attempts to connect to the server, send any data and retrieve any response. This is an asynchronous function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCallback</td><td>a function to call when the procedure is complete, its arguments are a <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> object containing the repsonse from the server, an unsigned int containing the value passed in nRunId and a string containing sUserData </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nRunId</td><td>a user defined identifier that will be passed to pCallback when it is called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sUserData</td><td>user defined string data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectionTimeout</td><td>the amount of time to wait for a connection to the server to be accepted before giving up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">processTimeout</td><td>the amount of time to wait for the whole connect, send, receive procedure to take place. If set to 0 then the timeout is ignored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>the amount of time to wait before running the function. This wait time may be longer depending on thread allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> a <a class="el" href="structpml_1_1restgoose_1_1clientResponse.html">clientResponse</a> object containing the HTTP repsonse code and any data sent from the server </dd></dl>

</div>
</div>
<a id="a1e6062051f9d0e1f74ba96617d241292" name="a1e6062051f9d0e1f74ba96617d241292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6062051f9d0e1f74ba96617d241292">&#9670;&#160;</a></span>SetBasicAuthentication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetBasicAuthentication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">userName</a> &amp;&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">password</a> &amp;&#160;</td>
          <td class="paramname"><em>pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use basic authenitication for the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>the usnername to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pass</td><td>the password to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>succesfully set basic authentication </td></tr>
    <tr><td class="paramname">false</td><td>if already called Run with a callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9906706a3a767131b6f0a54363b8e5d1" name="a9906706a3a767131b6f0a54363b8e5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9906706a3a767131b6f0a54363b8e5d1">&#9670;&#160;</a></span>SetBearerAuthentication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetBearerAuthentication </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sToken</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User Bearer Authentication for the connetion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sToken</td><td>the token to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>succesfully set basic authentication </td></tr>
    <tr><td class="paramname">false</td><td>if already called Run with a callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a429ce7c1bfd2b882448776a1675c03c1" name="a429ce7c1bfd2b882448776a1675c03c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429ce7c1bfd2b882448776a1675c03c1">&#9670;&#160;</a></span>SetCertificateAuthority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetCertificateAuthority </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>ca</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the file location of the certificate authority file to use (if any) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ca</td><td>the file location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback function </dd></dl>

</div>
</div>
<a id="afe99f7b4348e52972faeba7c5a70a165" name="afe99f7b4348e52972faeba7c5a70a165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe99f7b4348e52972faeba7c5a70a165">&#9670;&#160;</a></span>SetClientCertificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetClientCertificate </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>cert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the client certificate to use if server requires authentication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cert</td><td>the path to the certificate file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>the path to the private key file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback function </dd></dl>

</div>
</div>
<a id="aac64e5d4b2d3e9709de766db14d12d22" name="aac64e5d4b2d3e9709de766db14d12d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac64e5d4b2d3e9709de766db14d12d22">&#9670;&#160;</a></span>SetData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetData </td>
          <td>(</td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>jsData</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data to send (if a POST/PULL/PUT request) in JSON format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jsData</td><td>the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback function </dd></dl>

</div>
</div>
<a id="a7aa20d184fba981fe79e378eabd7c250" name="a7aa20d184fba981fe79e378eabd7c250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa20d184fba981fe79e378eabd7c250">&#9670;&#160;</a></span>SetData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">textData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data to send (if a POST/PULL/PUT request) in plain/text format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback function </dd></dl>

</div>
</div>
<a id="af631133be8a00e35ac1a09b1cf64f683" name="af631133be8a00e35ac1a09b1cf64f683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af631133be8a00e35ac1a09b1cf64f683">&#9670;&#160;</a></span>SetDownloadProgressCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::HttpClient::SetDownloadProgressCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(unsigned long, unsigned long)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pCallback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a callback function that is called every time a "chunk" of data is sent from the server. This is useful for showing the progress of large downloads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCallback</td><td>the callback function. It is passed two values: the first is the number of bytes downloaded and the second the total number of bytes that will be downloaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a712480b865b942dfbe72b412e4f489e8" name="a712480b865b942dfbe72b412e4f489e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712480b865b942dfbe72b412e4f489e8">&#9670;&#160;</a></span>SetEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the URL to connect to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the URL endpoint to connect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback function </dd></dl>

</div>
</div>
<a id="a131bd9848e5154efddfa8fcdce766027" name="a131bd9848e5154efddfa8fcdce766027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131bd9848e5154efddfa8fcdce766027">&#9670;&#160;</a></span>SetExpectedResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetExpectedResponse </td>
          <td>(</td>
          <td class="paramtype">const clientResponse::enumResponse&#160;</td>
          <td class="paramname"><em>eResponse</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the expected format of the response from the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eResponse</td><td>the expected format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback funtion </dd></dl>

</div>
</div>
<a id="a551d5ffa31057fc885b0f5dd1561e345" name="a551d5ffa31057fc885b0f5dd1561e345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551d5ffa31057fc885b0f5dd1561e345">&#9670;&#160;</a></span>SetFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">textData</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the file to upload (if a POST/PULL/PUT request) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the name of the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>the location of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback function </dd></dl>

</div>
</div>
<a id="a2d92bde9e242b605c51ddd39d53c7dda" name="a2d92bde9e242b605c51ddd39d53c7dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d92bde9e242b605c51ddd39d53c7dda">&#9670;&#160;</a></span>SetMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNamedType.html">httpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the HTTP method to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>the HTTP method (e.g. restgoose::GET) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback function </dd></dl>

</div>
</div>
<a id="a769fb2159fc0a25222d0d7523fe29d36" name="a769fb2159fc0a25222d0d7523fe29d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769fb2159fc0a25222d0d7523fe29d36">&#9670;&#160;</a></span>SetPartData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pml::restgoose::HttpClient::SetPartData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structpml_1_1restgoose_1_1partData.html">partData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vData</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the multipart data to send (if a POST/PULL/PUT request) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vData</td><td>the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool false if already called Run with a callback funtion </dd></dl>

</div>
</div>
<a id="a0dff210e334b070569f9e8d214e1029f" name="a0dff210e334b070569f9e8d214e1029f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dff210e334b070569f9e8d214e1029f">&#9670;&#160;</a></span>SetUploadProgressCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::HttpClient::SetUploadProgressCallback </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(unsigned long, unsigned long)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pCallback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a callback function that is called every time a "chunk" of data is sent to the server. This is useful for showing the progress of large uploads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pCallback</td><td>the callback function. It is passed two values: the first is the number of bytes uploaded and the second the total number of bytes that will be uploaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54b1d1cfeeacf0b28cdabca7fd2a78a0" name="a54b1d1cfeeacf0b28cdabca7fd2a78a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b1d1cfeeacf0b28cdabca7fd2a78a0">&#9670;&#160;</a></span>UseProxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pml::restgoose::HttpClient::UseProxy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the url of a proxy to use for the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>the url/ip address of the proxy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/oem/Restgoose/include/<a class="el" href="httpclient_8h_source.html">httpclient.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>pml</b></li><li class="navelem"><b>restgoose</b></li><li class="navelem"><a class="el" href="classpml_1_1restgoose_1_1HttpClient.html">HttpClient</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
